# ch01) c++
## 표준입출력을 위한 헤더파일 iostream을 전처리지시자 #include를 이용한다. 
    #include <iostream>
## 출력과 개행.
> 출력 std::cout

> 개행 std::endl

    #include <iostream>
    
    int main(void){
        std::cout<<"Hello World!"<<std::endl;
        return 0;
    }
## 데이터 입력.
>std::cin

    #include <iostream>
    
    int main(void){
        int val1;
        int val2;
        std::cin>>val1>>val2;

        int result = val1+val2;
        std::cout<<result<<std::endl;
        return 0;
    }
    
## 배열 기반의 문자열 입출력
    #include <iostream>
    using namespace std;

    int main(void){
        char name[100];
        char lang[200];

        cin>>name>>lang;

        cout<<"내 이름은 "<<name<<"좋아하는 언어는 "<<lang<<endl;
        return 0;
    }

## 함수의 오버로딩
>**C++는 함수호출 시 함수의 이름과 전달되는 인자의 정보를 동시에 참조하여 호출할 함수를 정한다.**

    //1번함수
    int MyFunc(int a){
        a++;
        return a;
    }
    //2번함수
    int MyFunc(int a, int b){
        return a+b;
    }

##
위와 같이 매개변수의 선언이 다르다면 이름이 동일한 함수도 선언할 수 있으며 이러한 함수의 정의를 Function Overloading이라고 한다.

    int main(void){
        MyFunc(10);         //1번 함수 실행
        MyFunc(10, 20);     //2번 함수 실행
        return 0;
    }
> 함수 오버로딩의 예

    int MyFunc(char c){...}
    int MyFunc(int n){...}

    int MyFunc(int n){...}
    int MyFunc(int n2, int n2){...}
> 반환형의 차이는 오버로딩의 조건을 만족하지 않는다.

    void MyFunc(int n){...}
    int MyFunc(int n){...}
    // X
## Default parameter
>인자를 전달하지 않으면 기본값이 전달되며 우측부터 정의해 주어야 한다.

Default parameter는 함수의 선언부에 위치시켜야한다.

    #include <iostream>
    using namespace std;
    int MyFunc(int a , int b = 7);

    int MyFunc(int a , int b){
        return a+b;
    }
    int main(void){
        cout<<MyFunc(3);    //10
        return 0;
    }


함수의 호출 시 인자는 앞에서부터 전달되기 때문에 Default parameter는 반드시 뒤쪽부터 비우지 않고 채워져야한다.

    int MyFunc(int a = 7, int b);           // X
    int MyFunc(int a , int b = 7, int c);   // X

## 매크로
> #define

    
    #include <iostream>
    using namespace std;
    define SQUARE(x) ((x)*(x))

    int main(void){
        cout<<SQUARE(5)<<endl;
        //전처리에 의해 아래와 같이 변한다
        //cout<<((5)*(5))<<endl;
        return 0;
    }

> 실행결과 : 25 

SQUARE(5)는 ((5)*(5))는 int형을<br>
SQUARE(3.15)는 ((3.15)*(3.15))는 double형 함수를 호출하게 된다. <br>**inline 함수와 다르게 자료형에 독립적이다.**

## 인라인 함수
> inline

매크로와 유사하게 함수가 호출되면 소스코드내에 인라인화된다.<br>
허나 매크로와 다르게 자료형에 독립적이지 못하다.<br>
함수 호출 시간이 줄어들어 프로그램의 실행 속도가 향상될 수 있다.

    #include <iostream>
    using namespace std;

    inline int SQUARE(int a){
        return a*a;
    }

    int main(void){
        cout<<SQUARE(5)<<endl;
        cout<<SQUARE(12)<<endl;
        return 0;
    }
SQUARE함수는 inline선언이 되어있기 때문에 컴파일러가

    cout<<SQUARE(5)<<endl;
를

    cout<<5*5<<endl;
으로
##
    cout<<SQUARE(12)<<endl;
를

    cout<<12*12<<endl;
으로 치환하여 프로그램을 실행하게 된다.

## namespace 와 중첩
>namespace를 단위로 함수와 변수가 선언되어있다.<br>아래는 namespace의 중첩과 예

    #include <iostream>
    using namespace std;
    namespace parent{
    int num = 2;
        namespace child1{
            int num =4;
        }
        namespace child2{
            int num =3;
        }
    }
    int main(void){
        cout<<parent::num<<"\n";
        cout<<parent::child1::num<<"\n";
        cout<<parent::child2::num<<"\n";
        
        return 0;
    }
> 실행결과<br>2<br>4<br>3<br>

## using을 이용한 namespace의 명시
    using namespace std::cin;
    using namespace std::cout;
    using namespace std::endl;
> 이후 사용할 cin, cout, endl은 std라는 namespace를 사용하겠다는것

    using namespace std;
> namespace std에 선언없이 접근할것이라는 뜻.

## namespace의 별칭
> namespace ABC = AAA::BBB::CCC;

    namespace AAA{
        namespace BBB{
            namespace CCC{
                int num1;
                int num2;
            }
        }
    }

namespace AAA::BBB::CCC에 ABC로 접근 가능하다.